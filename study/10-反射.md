# 反射

## 什么是反射
从定义上看，反射是指计算机程序在运行时（Run Time）可以访问、检测和修改它本身状态或行为的一种能力。简单来说，反射就是程序在运行时能够观察并修改自己的行为。

不同语言的反射机制不尽相同，有些语言不支持反射。Go语言的反射机制可以在运行时更新变量和检查它们的值，或者调用它们的函数方法，但是在编译时并不知道这些变量的数据类型。

编译语言在运行时需要对代码的词义、语法和语义执行编译过程，将代码转为汇编语言，再通过汇编程序把汇编语言翻译为机器指令，最后由计算机执行机器指令，从而完成整个程序的执行过程。

由于编译过程是不可逆的，如果代码在执行过程中需要访问、检测和修改它本身的状态或行为，这时候需要由反射机制实现。

反射机制的常用场景如下：

* 1）在定义函数的时候，函数参数没有设置特定的数据类型，比如将参数设置为空接口，如果需要对参数的数据类型或参数值进行判断，可以使用反射实现。
* 2）在调用函数的时候，根据if条件调用对应函数，可以对函数或参数进行反射，在运行期间能动态执行函数调用。

在程序中使用反射机制会对程序造成一定影响，说明如下：

* 1）使用反射的代码通常难以阅读，代码可读性反映了编程人员的技术水平，因此在编程中使用反射需要考虑代码的可读性。
* 2）Go语言作为静态语言，在编码过程中，编译器能提前发现语法错误，但是对于反射代码无能为力。所以包含反射相关的代码，很可能会运行很久才会出错，从而导致程序执行中断。
* 3）反射对计算机性能影响比较大，比正常代码运行速度慢得多，对于运行效率要求较高的代码尽量避免使用反射特性。

## 第一定律：接口变量转反射变量
Go语言是静态强类型的编程语言，在使用变量之前必须定义数据类型，由于空接口的数据类型是动态可变的，因此它能与反射机制灵活转换。

反射机制是由内置包reflect实现的，reflect包的两种基本类型为：Type和Value，它们分别对应两个方法：reflect.TypeOf()和reflect.ValueOf()，用来读取接口变量的数据类型和数值，使用方法如下：
```go
package main

import (
    "fmt"
    "reflect"
)

func main() {
    it := reflect.TypeOf(32)
    iv := reflect.ValueOf(32)
    fmt.Printf("整型类型：%v，反射类型：%T\n", it, it)
    fmt.Printf("整型的数值：%v，反射类型：%T\n", iv, iv)
    istrt := reflect.TypeOf("abc")
    istrv := reflect.ValueOf("abc")
    fmt.Printf("字符串类型：%v，反射类型：%T\n", istrt, istrt)
    fmt.Printf("字符串的数值：%v，反射类型：%T\n", istrv, istrv)
}
```

```
整型类型：int，反射类型：*reflect.rtype
整型的数值：32，反射类型：reflect.Value
字符串类型：string，反射类型：*reflect.rtype
字符串的数值：abc，反射类型：reflect.Value
```
函数reflect.TypeOf()获取变量的数据类型，reflect.ValueOf()获取变量的数值，其数据类型分别为*reflect.rtype和reflect.Value，它们已将变量转换为反射变量。

在整个转换过程中，我们并没有看到接口变量，那么反射第一定律是怎样将接口变量转换为反射变量的呢？其实从代码中看到，函数reflect.TypeOf()和reflect.ValueOf()可以设置任意数据类型的参数，打开reflect.TypeOf()的源码看到，函数参数为空接口

综上所述，内置包reflect的函数reflect.TypeOf()和reflect.ValueOf()能获取变量的数据类型和数值，并将变量转换为反射变量，它们对应的数据类型分别为*reflect.rtype和reflect.Value。

## 第二定律：反射变量转接口变量
既然接口变量能转换为反射变量，那么反射变量也能转换为接口变量。反射变量转换为接口变量是由reflect.ValueOf()调用Interface()方法实现的

由于函数reflect.ValueOf()的返回值是一个结构体变量，只要由它调用结构体方法Interface()就能实现反射变量与接口变量的转换功能，示例如下：
```go
package main

import (
    "fmt"
    "reflect"
)

func main() {
    num := 32
    fmt.Printf("转换前的数据：%v，数据类型：%T\n", num, num)
    iv := reflect.ValueOf(num)
    fmt.Printf("接口转换反射：%v，数据类型：%T\n", iv, iv)
    i := iv.Interface()
    fmt.Printf("反射转换接口：%v，数据类型：%T\n", i, i)
}

```

```
转换前的数据：32，数据类型：int
接口转换反射：32，数据类型：reflect.Value
反射转换接口：32，数据类型：int
```

上述代码将整数变量num转为反射变量iv，再由反射变量iv调用结构体方法Interface()转换为接口变量i。在整个转换过程中，变量值一直保存不变，只改变变量的数据类型

## 第三定律：修改反射变量的值
从反射的第一定律和第二定律得知，接口变量和反射变量实现相互转换，但在实际开发中，不仅要实现两者的相互转换，还需要修改其数值满足业务功能。

修改反射变量的数值可以使用CanSet()和SetFloat()等方法实现，比如将整型变量x转换为反射变量v，然后使用SetInt()方法修改变量值，实现代码如下：
```go
package main

import (
    "fmt"
    "reflect"
)

func main() {
    var x int = 66
    // reflect.ValueOf的参数设为变量x的指针
    v := reflect.ValueOf(&x)
    fmt.Printf("反射变量v的值：%v\n", v)
    fmt.Printf("反射变量v能否被修改：%v\n", v.CanSet())
    
    // 通过反射变量v的指针获取变量值
    vv := v.Elem()
    fmt.Printf("反射变量vv的值：%v\n", vv)
    fmt.Printf("反射变量vv能否被修改：%v\n", vv.CanSet())
    vv.SetInt(55)
    fmt.Printf("反射变量vv修改后的值：%v\n", vv)
    fmt.Printf("整型变量x的值：%v\n", x)
}
```

```
反射变量v的值：0xc00000e0a8
反射变量v能否被修改：false
反射变量vv的值：66
反射变量vv能否被修改：true
反射变量vv修改后的值：55
整型变量x的值：55
```
反射变量v是不允许被修改的。因为从整型变量转换为反射变量的过程中，反射变量只是拷贝整型变量的值。换句话说，反射变量与整型变量的值是相互独立的，所以反射变量使用SetInt()方法可以修改反射变量的值，但整型变量的数值并不会发生任何改变。

由于反射的概念是访问、检测和修改它本身状态或行为的一种能力，如果只改变反射变量的值而没有改变整型变量的值，那么这个修改就不符合反射概念。

为了防止这种情况发生，Go语言对反射变量设置了可写状态与不可写状态，从而有了CanSet()方法判断当前变量能否被修改。

如果要实现反射变量的可写状态，在使用reflect.ValueOf()的时候需要传入整型变量的指针变量，因为每个变量的内存地址是唯一的，通过修改内存地址对应的数值才能使反射变量和整型变量的数值达成一致

上述代码分别使用了reflect.ValueOf()、Elem()、CanSet()和SetInt()，实现过程说明如下：

* 1）定义整型变量x，变量值为66，使用函数reflect.ValueOf()将整型变量转换为反射变量，函数参数为整型变量的指针（内存地址）。
* 2）反射变量v的值是整型变量x的内存地址，若要从内存地址中获取数值，需要由反射变量使用Elem()方法获取，并赋值给反射变量vv。
* 3）反射变量vv使用CanSet()判断当前变量能否被修改，然后使用SetInt()将反射变量vv的值改为数值55。

不同数据类型的反射变量需要调用不同方法修改其变量值，比如变量值为整型，则调用SetInt()方法，浮点型则调用SetFloat()，所有数据类型的方法调用会在GoLand的代码提示功能中展示

综上所述，反射第三定律的实现过程如下：

* 1）修改反射变量的数值，在变量转换为反射变量的时候，必须将reflect.ValueOf()的参数设为变量的内存地址。
* 2）然后由反射变量使用Elem()方法获取变量的数值并赋值给新的反射变量。
* 3）再由新的反射变量使用SetInt()、SetFloat()等方法修改变量值。

## 反射的类型与种类
反射机制分为类型和种类，我们在编写代码的过程中，使用最多的是类型，种类是类型的上一级类别，比如猫科动物包括家猫、老虎、狮子和猎豹等，猫科动物相当于反射机制的种类，老虎、狮子相当于反射机制的类型。

反射机制的种类以Kind()表示，在Go安装目录的src文件夹能找到Kind()的定义过程

Kind()源码定义了多个种类，每个种类的说明如下：
```go
type Kind uint

const (

    Invalid Kind = iota     // 非法类型
    Bool                    // 布尔型
    Int                     // 有符号整型
    Int8                    // 有符号8位整型
    Int16                   // 有符号16位整型
    Int32                   // 有符号32位整型
    Int64                   // 有符号64位整型
    Uint                    // 无符号整型
    Uint8                   // 无符号8位整型
    Uint16                  // 无符号16位整型
    Uint32                  // 无符号32位整型
    Uint64                  // 无符号64位整型
    Uintptr                 // 指针
    Float32                 // 单精度浮点数
    Float64                 // 双精度浮点数
    Complex64               // 64位复数类型
    Complex128              // 128位复数类型
    Array                   // 数组
    Chan                    // 通道
    Func                    // 函数
    Interface               // 接口
    Map                     // 映射
    Ptr                     // 指针
    Slice                   // 切片
    String                  // 字符串
    Struct                  // 结构体
    UnsafePointer           // 底层指针
)
```

从Kind()定义的种类看到，每个种类就是Go语言的数据类型。既然反射的种类就是Go语言的数据类型，反射机制为什么还要区分类型和种类，这一切归功于关键字tpye，我们通过以下例子加以说明：
```go
package main

import (
    "fmt"
    "reflect"
)

type myint int

type cat struct {
    name string
}

func main() {
    var n int = 55
    rn := reflect.TypeOf(n)
    fmt.Printf("反射变量rn的类型：%v\n", rn)
    fmt.Printf("反射变量rn的类型：%v\n", rn.Name())
    fmt.Printf("反射变量rn所属的种类：%v\n", rn.Kind())

    var x myint = 66
    rx := reflect.TypeOf(x)
    fmt.Printf("反射变量rx的类型：%v\n", rx)
    fmt.Printf("反射变量rx的类型：%v\n", rx.Name())
    fmt.Printf("反射变量rx所属的种类：%v\n", rx.Kind())

    c := cat{name: "Lily"}
    vc := reflect.TypeOf(c)
    fmt.Printf("反射变量vc的类型：%v\n", vc)
    fmt.Printf("反射变量vc的类型：%v\n", vc.Name())
    fmt.Printf("反射变量vc所属的种类：%v\n", vc.Kind())
}
```

```
反射变量rn的类型：int
反射变量rn的类型：int
反射变量rn所属的种类：int
反射变量rx的类型：main.myint
反射变量rx的类型：myint
反射变量rx所属的种类：int
反射变量vc的类型：main.cat
反射变量vc的类型：cat
反射变量vc所属的种类：struct
```
我们对代码与运行结果进行分析，分析结果如下：

* 1）使用关键字type定义类型myint，它的数据类型为int类型，然后定义结构体cat。
* 2）分别创建整型变量n、自定义类型myint变量x和结构体实例化变量c，各自使用reflect.TypeOf()将其转换为反射变量，最后调用方法Name()和Kind()并输出相应结果。
* 3）reflect.TypeOf()转换反射变量能具体表明它来自哪个变量，如变量n是整型，自定义类型myint的变量x来自main包（main包即第一行代码package main）的myint类型，结构体实例化变量c来自main包定义的结构体cat。
* 4）换句话说，如果变量的数据类型是基本类型，如整型、字符串、浮点数等，那么reflect.TypeOf()直接返回对应的数据类型；如果变量的数据类型经过关键字type定义，那么reflect.TypeOf()返回该变量的定义位置，如结构体实例化变量c来自main包的结构体cat。
* 5）变量的数据类型只要经过关键字type定义，它的反射变量调用方法Name()就能获取变量的类型，调用方法Kind()就能获取变量的种类。比如自定义类型myint变量x的类型为myint，所属种类为int；结构体实例化变量c的类型为cat（即结构体名称），所属种类为struct。

## 切片与反射
反射可以通过reflect.TypeOf()和reflect.ValueOf()对任意变量进行转换。对于基本类型（整型、浮点型、字符串或布尔型等数据类型），使用Elem()和SetInt()等方法就能实现数据修改，如果变量是切片、集合等复杂一点的数据类型，则需要使用特定方法实现数据读取和修改。

切片与反射之间的转换也要遵从反射的第一定律和第二定律，切片转换为反射切片变量之后（为了方便理解，本书将切片转换的反射变量称为反射切片变量），使用reflect包提供的函数方法实现数据读取和修改，示例如下：
```go
package main

import (
    "fmt"
    "reflect"
)

func main() {
    s := []int{1, 2, 3, 4}
    sr := reflect.ValueOf(s)
    sl := sr.Len()
    fmt.Printf("Len()获取切片长度：%v，数据类型：%T\n", sl, sl)
    // 获取切片内存
    srp := sr.Pointer()
    fmt.Printf("Pointer()获取切片内存：%v，数据类型：%T\n", srp, srp)
    si := sr.Index(0)
    fmt.Printf("Index()读取某个元素：%v，数据类型：%T\n", si, si)
    // Set()修改切片元素
    si.Set(reflect.ValueOf(666))
    fmt.Printf("Set()修改某个元素：%v，数据类型：%T\n", sr, sr)
    // Slice3()第一个参数是切片元素的起始索引
    // 第二参数是提取的元素个数，第三个参数是切片元素的终止索引
    s3 := sr.Slice3(0, 3, 4)
    fmt.Printf("Slice3()截取元素：%v，数据类型：%T\n", s3, s3)
    // Slice()第一个参数是切片元素的起始索引
    // 第二个参数是切片元素的终止索引
    ss := sr.Slice(0, 1)
    fmt.Printf("Slice()截取元素：%v，数据类型：%T\n", ss, ss)
    // 反射切片变量转换接口变量，再由接口变量转换切片变量
    srr := sr.Interface().([]int)
    fmt.Printf("反射转换切片：%v\n", srr)
    // 为反射切片变量添加新的元素
    sr = reflect.Append(sr, reflect.ValueOf(666))
    fmt.Printf("Append()添加切片元素：%v\n", sr)
    // 两个反射切片变量合并一个新的反射切片变量
    sr = reflect.AppendSlice(sr, reflect.ValueOf([]int{777}))
    fmt.Printf("AppendSlice()添加合并切片：%v\n", sr)

    // 获取切片的数据类型
    sss := reflect.TypeOf(s)
    // 根据反射切片变量sss创建新的切片
    // MakeSlice()第一个参数是反射切片变量sss
    // 第二个参数切片长度，第三个参数切片容量
    nss := reflect.MakeSlice(sss, 0, 0)
    fmt.Printf("MakeSlice()创建新切片：%v，数据类型：%T\n", nss, nss)
    // 为新切片添加元素
    nss = reflect.Append(nss, reflect.ValueOf(100))
    fmt.Printf("Append()添加新切片元素：%v\n", nss)
}

```

```
Len()获取切片长度：4，数据类型：int
Pointer()获取切片内存：824633827808，数据类型：uintptr
Index()读取某个元素：1，数据类型：reflect.Value
Set()修改某个元素：[666 2 3 4]，数据类型：reflect.Value
Slice3()截取元素：[666 2 3]，数据类型：reflect.Value
Slice()截取元素：[666]，数据类型：reflect.Value
反射转换切片：[666 2 3 4]
Append()添加切片元素：[666 2 3 4 666]
AppendSlice()添加合并切片：[666 2 3 4 666 777]
MakeSlice()创建新切片：[]，数据类型：reflect.Value
Append()添加新切片元素：[100]
```
首先对切片s使用reflect.ValueOf()转换为反射切片变量，该变量可以实现数据读写操作；然后使用reflect.TypeOf()将切片s转换为另一个反射切片变量，该变量可以创建新的反射切片变量。

整个示例一共使用了12种方法实现反射切片变量的数据读写和创建操作，每种方法的作用与参数说明如下：

* 1）reflect.ValueOf()：将切片变量转为反射切片变量，其数据类型为reflect.Value，并返回切片变量的数值。
* 2）reflect.ValueOf().Len()：获取反射切片变量的长度。
* 3）reflect.ValueOf().Pointer()：获取切片的内存地址。
* 4）reflect.ValueOf().Index(i)：读取反射切片变量的某个元素。参数i的数据类型为整型，代表切片的下标索引。
* 5）reflect.ValueOf().Index(i).Set(reflect.ValueOf(v))：读取反射切片变量的某个元素并修改。参数i的数据类型为整型，代表切片的下标索引；参数v是修改后的元素值。
* 6）reflect.ValueOf().Slice3(i,j,k)：截取反射切片变量的切片元素。设有3个参数，参数的数据类型为整型，参数i是切片元素的起始索引，参数j是截取元素的个数，参数k是切片元素的终止索引。
* 7）reflect.ValueOf().Slice(i,j)：截取反射切片变量的切片元素。设有两个参数，参数的数据类型为整型，参数i是切片元素的起始索引，参数j是切片元素的终止索引。
* 8）reflect.ValueOf().Interface().([]int)：反射切片变量转换为接口变量，再由接口变量转换为切片变量。
* 9）reflect.Append(s,x)：为反射切片变量添加新的切片元素。参数s代表反射切片变量；参数x是reflect.Value类型的反射变量，代表新增元素。
* 10）reflect.AppendSlice(s,t)：两个反射切片变量合并为一个新的反射切片变量。参数s和t代表不同的反射切片变量。
* 11）reflect.TypeOf()：将切片变量转为反射切片变量，其数据类型为*reflect.rtype，它用于获取切片变量的数据类型。
* 12）reflect.MakeSlice(typ,len,cap)：根据反射切片变量的数据类型创建新的反射切片变量。设有3个参数，参数typ是*reflect.rtype类型的反射切片变量；参数len是切片的长度，参数类型为整型；参数cap是切片的容量，参数类型为整型。

综上所述，切片与反射之间的操作如下：

* 1）切片使用reflect.ValueOf()转换为反射切片变量，可以由该变量调用相关方法实现反射切片变量的读写操作（如获取切片长度、读取某个元素、修改元素、截取元素等）。
* 2）reflect.Append()对反射切片变量添加新的切片元素，reflect.AppendSlice()实现两个反射切片变量的合并操作。
* 3）切片使用reflect.TypeOf()转换为反射切片变量，并将该变量作为reflect.MakeSlice()的参数创建新的反射切片变量。

## 集合与反射
集合是以键值对表示的，它与JSON的数据格式非常相似，也是开发过程中常用的数据类型。当集合转换为反射的时候，可以通过reflect包提供的方法读写集合的键值对。为了方便理解，本书将集合转换的反射变量称为反射集合变量。

reflect包提供了9种方法操作反射集合变量，每种方法的使用方式如下：
```go
package main

import (
    "fmt"
    "reflect"
)

func main() {
    // 定义集合
    m := make(map[string]string)
    m["name"] = "Tom"
    m["age"] = "100"
    // 转换反射集合变量
    mr := reflect.ValueOf(m)
    // 获取键值对数量
    fmt.Printf("Len()获取键值对数量：%v\n", mr.Len())
    // 获取集合内存地址
    mrt := mr.Pointer()
    fmt.Printf("Pointer()获取集合内存地址：%v，数据类型：%T\n", mrt, mrt)
    // 获取集合所有的键
    mk := mr.MapKeys()
    fmt.Printf("MapKeys()获取键：%v，数据类型：%T\n", mk, mk)
    // 通过集合的键获取对应键值对
    mi := mr.MapIndex(mk[0])
    fmt.Printf("MapIndex()获取键值对：%v，数据类型：%T\n", mi, mi)
    // 获取集合的所有键值对
    iter := mr.MapRange()
    for iter.Next() {
        // 使用方法Next()输出所有键值对
        k := iter.Key()
        v := iter.Value()
        fmt.Printf("MapRange()获取集合的键：%v，集合的值：%v\n", k, v)
    }
    // 将反射集合变量转换接口变量，再由接口变量转换集合变量
    mm := mr.Interface().(map[string]string)
    fmt.Printf("反射转换集合：%v\n", mm["name"])
    // 添加新的键值对
    newKey := reflect.ValueOf("address")
    newValue := reflect.ValueOf("GuangZhou")
    mr.SetMapIndex(newKey, newValue)
    fmt.Printf("SetMapIndex()添加键值对：%v\n", mr)

    // 获取集合的数据类型
    mmm := reflect.TypeOf(m)
    // 根据反射变量mmm创建新的集合
    nmmm := reflect.MakeMap(mmm)
    // 添加新的键值对
    nmmm.SetMapIndex(newKey, newValue)
    fmt.Printf("MakeMap()创建新的集合：%v\n", nmmm)
}

```

```
Len()获取键值对数量：2
Pointer()获取集合内存地址：824634197168，数据类型：uintptr
MapKeys()获取键：[name age]，数据类型：[]reflect.Value
MapIndex()获取键值对：Tom，数据类型：reflect.Value
MapRange()获取集合的键：name，集合的值：Tom
MapRange()获取集合的键：age，集合的值：100
反射转换集合：Tom
SetMapIndex()添加键值对：map[address:GuangZhou age:100 name:Tom]
MakeMap()创建新的集合：map[address:GuangZhou]
```

结合代码和运行结果分析得知，reflect.ValueOf()转换的反射集合变量可以实现集合的键值对读写操作，reflect.TypeOf()转换的反射集合变量可以创建新的反射集合变量，它们调用不同的方法实现，每种方法的作用与参数说明如下：

* 1）reflect.ValueOf()：将集合转为反射集合变量，其数据类型为reflect.Value，并返回集合的键值对。
* 2）reflect.ValueOf().Len()：获取反射集合变量的所有键值对数量。
* 3）reflect.ValueOf().Pointer()：获取切片的内存地址。
* 4）reflect.ValueOf().MapKeys()：获取反射集合变量的键，并以切片形式表示。
* 5）reflect.ValueOf().MapIndex(key)：获取反射集合变量某个键所对应的值。参数key是reflect.Value类型，代表所有键值对的某个键。
* 6）reflect.ValueOf().MapRange()：获取反射集合变量的所有键值对，使用for循环并调用Next()、Key()和Value()方法遍历每个键值对。
* 7）reflect.ValueOf().Interface().(map[string]string)：反射集合变量转换为接口变量，再由接口变量转换为集合变量。
* 8）reflect.ValueOf().SetMapIndex(key, elem)：为反射集合变量添加或修改键值对，如果键不存在则执行新增，如果键存在则执行修改。参数key和elem是reflect.Value类型的，分别代表键值对的键和值。
* 9）reflect.TypeOf()：将集合转为反射集合变量，其数据类型为*reflect.rtype，它能获取集合变量的数据类型。
* 10）reflect.MakeMap(typ)：创建新的反射集合变量。参数typ是*reflect.rtype类型的，代表反射集合变量的数据类型。

综上所述，集合与反射之间的操作如下：

* 1）集合使用reflect.ValueOf()转换为反射集合变量，可以由该变量调用相关方法实现反射集合变量的读写操作（如获取长度、读取某个键值对或所有键值对、添加新的键值对等）。
* 2）集合使用reflect.TypeOf()转换为反射集合变量，并将该变量作为reflect. MakeMap()的参数创建新的反射集合变量。

## 结构体与反射
结构体是Go语言中最重要的数据类型之一，结构体主要由结构体成员和结构体方法组成，结构体成员又分为成员名称、标签和数值。结构体转换为反射结构体变量，可以使用reflect包提供的函数方法实现结构体成员和结构体方法的读写操作。

我们首先讲述反射机制如何读写结构体成员，实现过程如下：
```go
package main

import (
    "fmt"
    "reflect"
    "strings"
)

// 定义结构体
type cat struct {
    Name string
    Age  int `json:"age" id:"101"`
}

// 定义结构体方法
func (c *cat) speak() {
    fmt.Printf("喵喵喵")
}

// 定义函数
func GetFieldByIndex(a string) bool {
    return strings.ToLower(a) == "name"
}

func main() {
    // 创建结构体变量
    c := cat{Name: "Lily", Age: 18}
    // ValueOf()创建反射结构体变量
    vc := reflect.ValueOf(c)
    // 计算成员数量
    vnu := vc.NumField()
    fmt.Printf("NumField()计算成员数量：%v，数据类型：%T\n", vnu, vnu)
    // 以成员名称访问成员值
    vn := vc.FieldByName("Name")
    fmt.Printf("FieldByName()访问某个成员：%v，数据类型：%T\n", vn, vn)
    // 以成员排序索引访问成员值
    vi := vc.Field(1)
    fmt.Printf("Field()访问某个成员：%v，数据类型：%T\n", vi, vi)
    // 以成员排序索引访问成员值，索引值以切片表示
    vbi := vc.FieldByIndex([]int{0})
    fmt.Printf("FieldByIndex()访问某个成员：%v，数据类型：%T\n", vbi, vbi)
    // 以函数方式判断并获取某个成员名称，再从成员名称获取成员值
    vf := vc.FieldByNameFunc(GetFieldByIndex)
    fmt.Printf("FieldByNameFunc()访问某个成员：%v，数据类型：%T\n", vf, vf)
    // 判断反射结构体变量能否修改数据
    fmt.Printf("反射结构体变量能否修改数据：%v\n", vc.CanSet())

    // ValueOf()创建反射结构体指针变量
    vc_pit := reflect.ValueOf(&c)
    // 获取所有成员的值
    ve := vc_pit.Elem()
    fmt.Printf("Elem()获取所有成员的值：%v，数据类型：%T\n", ve, ve)
    // 判断反射结构体指针变量能否修改数据
    fmt.Printf("反射结构体指针变量能否修改数据：%v\n", ve.CanSet())
    // Set()、SetInt()等方法设置成员值
    ve.FieldByName("Name").SetString("Tom")
    ve.FieldByName("Name").Set(reflect.ValueOf("Tim"))
    ve.FieldByName("Age").SetInt(666)
    fmt.Printf("Set()、SetInt()等方法设置成员值：%v\n", ve)

    // TypeOf()创建反射结构体变量
    vt := reflect.TypeOf(c)
    // 遍历结构体所有成员数量
    for i := 0; i < vt.NumField(); i++ {
        // 获取每个成员的结构体成员类型
        vinfo := vt.Field(i)
        // 输出成员名和tag
        fmt.Printf("结构成员：%v，其标签为：%v\n", vinfo.Name, vinfo.Tag)
    }
    // 通过成员名, 找到成员类型信息
    if cn, ok := vt.FieldByName("age"); ok {
        // 从tag中取出需要的tag
        fmt.Printf("标签json的内容：%v\n", cn.Tag.Get("json"))
        fmt.Printf("标签id的内容：%v\n", cn.Tag.Get("id"))
    }
    // 通过成员索引, 找到成员类型信息，索引以切片形式表示
    ct := vt.FieldByIndex([]int{1})
    fmt.Printf("标签json的内容：%v\n", ct.Tag.Get("json"))
    fmt.Printf("标签id的内容：%v\n", ct.Tag.Get("id"))
}

```

```
NumField()计算成员数量：2，数据类型：int
FieldByName()访问某个成员：Lily，数据类型：reflect.Value
Field()访问某个成员：18，数据类型：reflect.Value
FieldByIndex()访问某个成员：Lily，数据类型：reflect.Value
FieldByNameFunc()访问某个成员：Lily，数据类型：reflect.Value
反射结构体变量能否修改数据：false
Elem()获取所有成员的值：{Lily 18}，数据类型：reflect.Value
反射结构体指针变量能否修改数据：true
Set()、SetInt()等方法设置成员值：{Tim 666}
结构成员：Name，其标签为：
结构成员：Age，其标签为：json:"age" id:"101"
标签json的内容：age
标签id的内容：101
```

代码分别使用reflect.TypeOf()和reflect.ValueOf()将结构体cat转换为反射变量。reflect.ValueOf()转换的反射变量能获取和修改成员值，reflect.TypeOf()转换的反射变量能获取结构体成员名称和标签，说明如下：

* 1）reflect.ValueOf(c)：将结构体转为反射结构体变量，数据类型为reflect.Value，并返回结构体的成员值。
* 2）reflect.ValueOf(c).NumField()：获取结构体所有成员数量。
* 3）reflect.ValueOf(c).FieldByName(name)：通过成员名称获取某个成员信息。参数name以字符串表示，代表成员名称。
* 4）reflect.ValueOf(c).Field(i)：通过成员排序索引获取某个成员信息。参数i为整型，代表成员在结构体中定义的先后顺序。
* 5）reflect.ValueOf(c).FieldByIndex(index)：通过成员的排序索引获取某个成员信息。参数index以切片表示，切片只能有一个元素，该元素代表成员在结构体中定义的先后顺序，如果切片元素数量大于1，程序将提示异常。
* 6）reflect.ValueOf(c).FieldByNameFunc(match)：通过函数获取某个成员信息。参数match以函数表示，函数必须设有字符串参数a，返回值为布尔型，当函数参数a等于某个成员名称的时候，函数必须返回布尔型，若为true，则获取成员信息，若为false，则继续判断其他成员名称。函数match只能为一个结构体成员返回true，如果为多个成员返回true，程序将提示异常。
* 7）reflect.ValueOf(c).CanSet()：判断反射结构体变量能否被修改，判断结果为false，表示不能修改。
* 8）reflect.ValueOf(&c)：将结构体指针转换为反射结构体指针变量，数据类型为reflect.Value。
* 9）reflect.ValueOf(&c).Elem()：从反射结构体指针变量获取结构体成员信息。
* 10）reflect.ValueOf(&c).Elem().CanSet()：判断反射结构体指针变量能否被修改，判断结果为true，表示能被修改。
* 11）reflect.ValueOf(&c).Elem().FieldByName(name). SetString(x)：从反射结构体指针变量获取某个成员信息，并修改其数值。FieldByName(name)的参数name代表成员名称，SetString(x)的参数x代表修改值。
* 12）Set()、SetInt()和SetFloat()等方法皆可修改成员值，根据成员值的数据类型调用相应方法。
* 13）reflect.TypeOf(c)：将结构体转为反射结构体变量，数据类型为*reflect.rtype，它能获取结构体的数据类型。
* 14）reflect.TypeOf(c).NumField()：获取结构体所有成员数量。
* 15）reflect.TypeOf(c).Field(i)：通过成员的排序索引获取某个成员信息。参数i为整型，代表成员在结构体中定义的先后顺序。
* 16）reflect.TypeOf(c).Field(i).Name：获取某个成员的成员名称。
* 17）reflect.TypeOf(c).Field(i).Tag：获取某个成员的所有标签。
* 18）reflect.TypeOf(c).FieldByName(name).Tag.Get(key)：通过FieldByName()获取某个成员信息，参数name以字符串表示，代表成员名称；Tag是从成员信息获取标签；Get(key)是从标签中获取某个键值对，参数key代表某个键值对的键。

综上所述，结构体与反射之间的转换与操作说明如下：

* 1）使用reflect.ValueOf(struct)转换为反射结构体变量，只能获取结构体成员的数值，但不能对其修改。
* 2）使用reflect.ValueOf(&struct)转换为反射结构体指针变量，必须调用Elem()方法才能访问结构体成员，并且能修改成员值。
* 3）使用reflect.TypeOf(struct)转换为反射结构体变量，只能访问结构体成员名称和标签。
* 4）上述3种转换方式皆可调用NumField()、FieldByName(name)、Field(i)、FieldByIndex(index)和FieldByNameFunc(match)获取成员信息。
* 5）结构体成员的首个字母必须大写，将其设置为导出标识符，否则反射结构体变量无法访问成员。

上述例子仅对结构体的成员执行读写操作，若要对结构体方法执行调用操作，其实现过程如下：
```go
package main

import (
    "fmt"
    "reflect"
)

// 定义结构体
type cat struct {
    Name string
    Age  int `json:"age" id:"101"`
}

// 定义结构体方法，指针接收者
func (c *cat) Speak() {
    fmt.Printf("喵...喵...喵\n")
}

// 定义结构体方法，值接收者
func (c cat) Talk() {
    fmt.Printf("喵...喵...喵\n")
}

// 定义结构体方法，带返回值
func (c cat) Sleep() string {
    fmt.Printf("Z...Z...Z\n")
    return "Sleep"
}

// 定义结构体方法，带参数和返回值
func (c cat) Run(a string) {
    fmt.Printf("run...run...%v\n", a)
}

// 定义结构体方法，带参数和返回值
func (c cat) Eat(a string) string {
    fmt.Printf("chi...chi...%v\n", a)
    return "Eat"
}

func main() {
    // 创建结构体变量
    c := cat{Name: "Lily", Age: 18}
    // 创建反射结构体指针变量
    vc := reflect.ValueOf(&c)
    // 创建反射结构体变量
    //vc := reflect.ValueOf(c)

    // MethodByName()获取Speak()，Call()调用Speak()
    cs := vc.MethodByName("Speak")
    cs.Call(make([]reflect.Value, 0))

    // MethodByName()获取Talk()，Call()调用Talk()
    ct := vc.MethodByName("Talk")
    ct.Call(make([]reflect.Value, 0))

    // MethodByName()获取Sleep()，Call()调用Sleep()
    css := vc.MethodByName("Sleep")
    r := css.Call(make([]reflect.Value, 0))
    fmt.Printf("Sleep()返回值：%v\n", r)

    // MethodByName()获取Run()，Call()调用Run()
    cr:= vc.MethodByName("Run")
    cr.Call([]reflect.Value{reflect.ValueOf("GOGOGO")})

    // MethodByName()获取Eat()，Call()调用Eat()
    cea:= vc.MethodByName("Eat")
    rr := cea.Call([]reflect.Value{reflect.ValueOf("mouse")})
    fmt.Printf("Eat()返回值：%v\n", rr)
}
```

```
喵...喵...喵
喵...喵...喵
Z...Z...Z
Sleep()返回值：[Sleep]
run...run...GOGOGO
chi...chi...mouse
Eat()返回值：[Eat]
```
我们为结构体cat定义了5个方法，每个方法的定义过程略有不同，具体说明如下：

* 1）Speak()：没有参数和返回值，方法类型为指针接收者。
* 2）Talk()：没有参数和返回值，方法类型为值接收者。
* 3）Sleep()：没有参数，有返回值，方法类型为值接收者。
* 4）Run()：有参数，没有返回值，方法类型为值接收者。
* 5）Eat()：有参数和返回值，方法类型为值接收者。

如果结构体方法通过反射机制进行调用，结构体方法的名称首个字母必须大写，这是将结构体方法设为导出标识符，否则反射无法调用，并提示异常。

由反射机制调用结构体方法，结构体必须使用reflect.ValueOf()转换，转换结果分为反射结构体变量和反射结构体指针变量，两者的区别在于能否调用指针接收者的结构体方法。反射结构体变量无法调用指针接收者的结构体方法，反射结构体指针变量能调用值接收者和指针接收者的结构体方法。

在上述示例中将结构体cat转换为反射结构体指针变量，并依次调用了5个结构体方法，调用过程都是由反射结构体指针变量调用MethodByName()获取某个结构体方法，再调用Call()方法完成整个调用过程。

Call()方法不论结构体方法是否有参数，都必须为Call()设置参数值。Call()的参数类型为切片，切片元素为reflect.Value类型，设置说明如下：

* 1）如果结构体方法没有参数，Call()的参数设为make([]reflect.Value, 0)。
* 2）如果结构体方法有参数，Call()的参数应设为[]reflect.Value{s1,s2,…}，切片元素值为reflect.ValueOf(参数值)。

反射除了能调用结构体方法之外，还能获取结构体方法的基本信息，示例如下：
```go
package main

import (
    "fmt"
    "reflect"
)

// 定义结构体
type cat struct {
    Name string
    Age  int `json:"age" id:"101"`
}

// 定义结构体方法，指针接收者
func (c *cat) Speak() {
    fmt.Printf("喵...喵...喵\n")
}

// 定义结构体方法，值接收者
func (c cat) Talk() {
    fmt.Printf("喵...喵...喵\n")
}

// 定义结构体方法，带返回值
func (c cat) Sleep() string {
    fmt.Printf("Z...Z...Z\n")
    return "Sleep"
}

// 定义结构体方法，带参数和返回值
func (c cat) Run(a string) {
    fmt.Printf("run...run...%v\n", a)
}

// 定义结构体方法，带参数和返回值
func (c cat) Eat(a string) string {
    fmt.Printf("chi...chi...%v\n", a)
    return "Eat"
}

func main() {
    // 创建结构体变量
    c := cat{Name: "Lily", Age: 18}

    // TypeOf()创建反射结构体变量
    vt := reflect.TypeOf(c)
    // 创建反射结构体指针变量
    //vt := reflect.TypeOf(&c)
    // NumMethod()获取所有结构体方法
    fmt.Printf("NumMethod()获取所有结构体方法：%v\n", vt.NumMethod())
    vmm, _ := vt.MethodByName("Talk")
    fmt.Printf("Func获取方法的内存地址：%v\n", vmm)
    // 遍历输出每个方法的信息
    for i := 0; i < vt.NumMethod(); i++ {
        // 遍历NumMethod()，通过Method(i).Name获取方法名
        fmt.Printf("Name获取方法名：%v\n", vt.Method(i).Name)
        fmt.Printf("PkgPath获取方法所在包名：%v\n", vt.Method(i).PkgPath)
        fmt.Printf("Func获取方法的内存地址：%v\n", vt.Method(i).Func)
        fmt.Printf("Type获取方法的类型：%v\n", vt.Method(i).Type)
        fmt.Printf("Index获取方法的索引：%v\n", vt.Method(i).Index)
    }

    // 创建反射结构体指针变量
    //vc := reflect.ValueOf(&c)
    // 创建反射结构体变量
    vc := reflect.ValueOf(c)
    // 获取结构体方法
    ctn := vc.MethodByName("Eat")
    fmt.Printf("MethodByName()获取方法的内存地址：%v\n", ctn)
    // 获取结构体方法
    cty := vc.Method(0)
    fmt.Printf("Method()获取方法的内存地址：%v\n", cty)
    // 获取方法的类型
    fmt.Printf("Type()获取方法的类型：%v\n", cty.Type())
}

```

```
NumMethod()获取所有结构体方法：4
Func获取方法的内存地址：{Talk  func(main.cat) <func(main.cat) Value> 3}
Name获取方法名：Eat
PkgPath获取方法所在包名：
Func获取方法的内存地址：0x37d1e0
Type获取方法的类型：func(main.cat, string) string
Index获取方法的索引：0
Name获取方法名：Run
PkgPath获取方法所在包名：
Func获取方法的内存地址：0x37d120
Type获取方法的类型：func(main.cat, string)
Index获取方法的索引：1
Name获取方法名：Sleep
PkgPath获取方法所在包名：
Func获取方法的内存地址：0x37d0c0
Type获取方法的类型：func(main.cat) string
Index获取方法的索引：2
Name获取方法名：Talk
PkgPath获取方法所在包名：
Func获取方法的内存地址：0x37d060
Type获取方法的类型：func(main.cat)
Index获取方法的索引：3
MethodByName()获取方法的内存地址：0x33ca80
Method()获取方法的内存地址：0x33ca80
Type()获取方法的类型：func(string) string
```

从示例代码和运行结果分析得知，reflect.TypeOf()转换的反射结构体变量或反射结构体指针变量能获取结构体方法的名称、位置索引、类型和内存地址，reflect.ValueOf()转换的反射结构体变量或反射结构体指针变量能获取方法内存地址和类型，说明如下：

* 1）reflect.TypeOf()：将结构体转为反射结构体变量，其数据类型为*reflect.rtype，它能获取结构体的数据类型。
* 2）reflect.TypeOf().NumMethod()：获取当前结构体定义了多少个方法。
* 3）reflect.TypeOf().MethodByName(s)：通过方法名找到结构体方法。参数s代表结构体方法名称。
* 4）reflect.TypeOf().Method(i)：获取某个结构体方法。参数i代表该方法在结构体中的定义次序。
* 5）reflect.TypeOf().Method(i).Name：获取某个结构体方法的名字。
* 6）reflect.TypeOf().Method(i).PkgPath：获取某个结构体方法所在的包名，比如go文件的package main，main代表包名，也是程序的主入口。
* 7）reflect.TypeOf().Method(i).Func：获取某个结构体方法的内存地址，在Func后面可以调用Call()实现方法调用，但程序运行却提示异常。
* 8）reflect.TypeOf().Method(i).Type：获取某个结构体方法的数据类型。
* 9）reflect.TypeOf().Method(i).Index：获取某个结构体方法的定义次序。
* 10）reflect.ValueOf()：结构体转为反射结构体变量，数据类型为reflect.Value，并获取结构体的数据。
* 11）reflect.ValueOf().MethodByName(s)：通过方法名找到结构体方法。参数s代表结构体方法名称。
* 12）reflect.ValueOf().Method(i)：获取某个结构体方法。参数i代表该方法在结构体中的定义次序。
* 13）reflect.ValueOf().Method(i).Type()：获取某个结构体方法的数据类型。

综上所述，结构体使用reflect.ValueOf()转换反射结构体变量能获取、修改结构体的成员值和调用结构体方法，使用reflect.TypeOf()转换反射结构体变量能获取成员名称、标签内容、方法名称等属性信息。

## 指针与反射
指针是一种数据类型，它用于记录变量的内存地址，无论变量是什么类型的数据，指针都能保存它对应的内存地址。在Go语言中，数据类型主要分为基本类型和复合类型，划分标准如下：

1）基本类型：该类型的数据只能由一种数据类型表示，如整型、布尔型、字符串、字符、浮点型、复数、指针。

2）复合类型：该类型的数据可以由多种不同类型的数据组合而成，如数组、切片、集合、列表、函数、结构体、接口、通道。

虽然指针是基本类型，但它能保存任何数据类型的内存地址，这一点较为特别，所以反射机制定义了相应方法执行指针操作，示例如下：
```go
package main

import (
    "fmt"
    "reflect"
)

// 定义结构体
type cat struct {
    Name string
    Age  int `json:"age" id:"101"`
}

func main() {
    // 字符串
    s := "golang"
    vs := reflect.ValueOf(&s)
    fmt.Printf("反射字符串指针的内存：%v，数值：%v\n", vs, vs.Elem())
    vs.Elem().SetString("hello")
    fmt.Printf("反射字符串指针的内存：%v，数值：%v\n", vs, vs.Elem())

    // 切片
    sli := []interface{}{1, 2, "Go"}
    vsli := reflect.ValueOf(&sli)
    fmt.Printf("反射切片指针的内存：%v，数值：%v\n", vsli, vsli.Elem())
    vsli.Elem().Index(0).Set(reflect.ValueOf("golang"))
    fmt.Printf("反射切片指针的内存：%v，数值：%v\n", vsli, vsli.Elem())

    // 集合
    m := make(map[string]interface{})
    m["name"] = "Tim"
    vm := reflect.ValueOf(&m)
    fmt.Printf("反射集合指针的内存：%v，数值：%v\n", vm, vm.Elem())
    rv := reflect.ValueOf("name")
    rk := reflect.ValueOf("golang")
    vm.Elem().SetMapIndex(rv, rk)
    fmt.Printf("反射集合指针的内存：%v，数值：%v\n", vm, vm.Elem())

    // 结构体
    c := cat{Name: "Lily", Age: 18}
    vcp := reflect.ValueOf(&c).Pointer()
    fmt.Printf("反射结构体指针的内存：%v，数值：%v\n", vcp, vcp)
    vc := reflect.ValueOf(&c)
    fmt.Printf("反射结构体指针的内存：%v，数值：%v\n", vc, vc.Elem())
    vc.Elem().FieldByName("Name").Set(reflect.ValueOf("Tom"))
    fmt.Printf("反射结构体指针的内存：%v，数值：%v\n", vc, vc.Elem())

    // 指针
    var prt *string
    name := "point"
    // 给指针赋于变量name的内存地址
    prt = &name
    vpp := reflect.ValueOf(&prt)
    fmt.Printf("反射指针的指针内存：%v，数值：%v\n", vpp, vpp.Elem())
    vp := reflect.ValueOf(prt)
    fmt.Printf("反射指针的内存：%v，数值：%v\n", vp, vp.Elem())
    // 使用反射创建新指针
    nprt := reflect.New(reflect.TypeOf(*prt))
    fmt.Printf("新反射指针的内存：%v，数值：%v\n", nprt, nprt.Elem())
    nprt.Elem().Set(reflect.ValueOf(name))
    fmt.Printf("新反射指针的内存：%v，数值：%v\n", nprt, nprt.Elem())
    // 使用反射创建新指针的指针
    nprtt := reflect.New(reflect.TypeOf(prt))
    fmt.Printf("新反射指针的指针内存：%v，数值：%v\n", nprtt, nprtt.Elem())
    nprtt.Elem().Set(reflect.ValueOf(&name))
    fmt.Printf("新反射指针的指针内存：%v，数值：%v\n", nprtt, nprtt.Elem())
}

```

```
反射字符串指针的内存：0xc000054260，数值：golang
反射字符串指针的内存：0xc000054260，数值：hello
反射切片指针的内存：&[1 2 Go]，数值：[1 2 Go]
反射切片指针的内存：&[golang 2 Go]，数值：[golang 2 Go]
反射集合指针的内存：&map[name:Tim]，数值：map[name:Tim]
反射集合指针的内存：&map[name:golang]，数值：map[name:golang]
反射结构体指针的内存：824633754320，数值：824633754320
反射结构体指针的内存：&{Lily 18}，数值：{Lily 18}
反射结构体指针的内存：&{Tom 18}，数值：{Tom 18}
反射指针的指针内存：0xc00000a038，数值：0xc000054360
反射指针的内存：0xc000054360，数值：point
新反射指针的内存：0xc000054390，数值：
新反射指针的内存：0xc000054390，数值：point
新反射指针的指针内存：0xc00000a040，数值：<nil>
新反射指针的指针内存：0xc00000a040，数值：0xc000054360
```

上述示例演示了字符串、切片、集合、结构体、指针与反射的转换过程和数据操作，说明如下：

* 1）字符串、切片、集合、结构体的反射指针变量分别将字符串、切片、集合、结构体的内存地址转换为相应反射变量，然后调用对应函数方法实现数据读写操作。这些变量转换为反射指针变量的过程都是相同的，数据读写操作则需要调用各自特定的函数方法。
* 2）指针转换为反射指针变量需要传入指针本身的内存地址，而非指针记录的内存地址。指针是一个变量，也有自己的内存地址，它记录的内存地址是另一个变量的内存地址，这一概念必须梳理清楚。比如reflect.ValueOf(&prt)能得到指针本身的内存地址，调用Elem()方法能得到指针记录的内存地址（即某个变量的内存地址）。
* 3）指针转换为反射变量只要传入指针的变量名称即可，如reflect.ValueOf(prt)，它能得到指针记录的内存地址，调用Elem()方法能得到该内存地址所存放的变量值。
* 4）当指针转换为反射指针变量的时候，使用reflect.New()可以创建新的反射指针变量，如reflect.New(reflect.TypeOf(*prt))，*prt是对指针prt使用取值操作符“*”，从而生成新的指针变量。
* 5）使用reflect.New(reflect.TypeOf(prt))还可以创建新的反射指针的指针变量，若要为该变量赋值，则必须对变量值使用取址操作符“&”，如reflect.ValueOf(&name)。

## 函数与反射
函数是所有编程语言都具备的数据类型之一，在Go语言中，函数和方法代表不同的数据类型，函数是可以独立存在的，而方法必须依附结构体。反射机制可以将函数转换为反射函数变量，再调用反射函数变量完成函数调用过程。

我们知道函数定义可以分为4种类型，分别是：

* 无参数，无返回值。
* 有参数，无返回值。
* 无参数，有返回值。
* 有参数，有返回值。

反射函数变量也是根据函数定义划分为4种不同类型，在调用过程中也会发生细微差异，示例如下：
```go
package main

import (
    "fmt"
    "reflect"
)

// 定义无参数无返回值的函数
func myfunc() {
    fmt.Printf("This is myfunc, 6666\n")
}

// 定义带参数无返回值的函数
func myfunc1(name string) {
    fmt.Printf("This is myfunc1, para is %v\n", name)
}

// 定义无参数带返回值的函数
func myfunc2() string {
    fmt.Printf("This is myfunc2, 6666\n")
    return "6666"
}

// 定义带参数带返回值的函数
func myfunc3(name string) string {
    fmt.Printf("This is myfunc3, para is %v\n", name)
    return "7777"
}

func main() {
    // 反射无参数无返回值的函数
    mf := reflect.ValueOf(myfunc)
    // 判断反射函数变量的类型
    fmt.Println("rf is reflect.Func?", mf.Kind() == reflect.Func)
    // 调用反射函数，无参数可设为nil
    mf.Call(nil)

    // 反射带参数无返回值的函数
    mf1 := reflect.ValueOf(myfunc1)
    // 判断反射函数变量的类型
    fmt.Println("rf1 is reflect.Func?", mf1.Kind() == reflect.Func)
    // 调用反射函数，函数参数必须为reflect.Value类型的切片
    // 切片元素顺序对应函数参数的顺序
    mf1.Call([]reflect.Value{reflect.ValueOf("Tom")})

    // 反射无参数带返回值的函数
    mf2 := reflect.ValueOf(myfunc2)
    // 判断反射函数变量的类型
    fmt.Println("rf2 is reflect.Func?", mf2.Kind() == reflect.Func)
    // 调用反射函数，无参数可设为nil
    myr2 := mf2.Call(nil)
    // 输出返回值的数据和类型
    fmt.Printf("myfunc2 return is %v, %T\n", myr2, myr2)

    // 反射带参数带返回值的函数
    mf3 := reflect.ValueOf(myfunc3)
    // 判断反射函数变量的类型
    fmt.Println("mf3 is reflect.Func?", mf3.Kind() == reflect.Func)
    // 调用反射函数，函数参数必须为reflect.Value类型的切片
    // 切片元素顺序对应函数参数的顺序
    myr3 := mf3.Call([]reflect.Value{reflect.ValueOf("Tom")})
    // 输出返回值的数据和类型
    fmt.Printf("myfunc2 return is %v, %T\n", myr3, myr3)
}

```

```
rf is reflect.Func? true
This is myfunc, 6666
rf1 is reflect.Func? true
This is myfunc1, para is Tom
rf2 is reflect.Func? true
This is myfunc2, 6666
myfunc2 return is [6666], []reflect.Value
mf3 is reflect.Func? true
This is myfunc3, para is Tom
myfunc2 return is [7777], []reflect.Value
```

不同类型的反射函数变量在调用过程中只需考虑函数参数和返回值，函数调用是使用反射机制的Call()方法实现的，说明如下：

* 1）如果函数没有参数，Call()方法的参数设为空值（nil）。
* 2）如果函数有参数，Call()方法的参数值必须为reflect.Value类型的切片，切片元素的排序对应参数先后顺序。
* 3）如果函数有返回值，为Call()方法赋予某个变量即可获取函数返回值。

总的来说，反射机制将函数转换为反射函数变量，主要是实现函数调用，在调用过程中可以实现监控检测功能，比如检测函数的执行时长。

## 动手练习：编程实现对象序列化处理
Go语言的反射机制常用于对象序列化处理，内置包encoding/json、encoding/xml、encoding/gob、encoding/binary都依赖反射功能实现。以8.9节为例，结构体转换为JSON的时候，通过设置结构体成员标签就能设置JSON的键，这一功能就是通过反射实现的，这也是对象序列化处理。

对象序列化处理说白了就是对结构体成员标签进行读取，对读取结果执行数据处理。结构体成员标签读取只能通过反射机制实现，实现过程如下：

* 1）定义结构体，结构体成员的一个标签以key:"value"形式表示，key和value之间使用冒号隔开并且不能留有空格，如果有多个标签，标签之间使用空格隔开即可。
* 2）实例化结构体，使用reflect.TypeOf()对结构体实例化对象进行反射处理，生成反射结构体变量。
* 3）由反射结构体变量调用相应方法获取每个结构体成员，再由每个结构体成员调用Tag.Get()方法获取标签，最后将标签数据写入某个变量或执行数据处理。

我们将对象序列化的实现过程以代码形式呈现，代码如下：
```go
package main

import (
    "fmt"
    "reflect"
)

type Persons struct {
    N string `key:"Name" value:"李四"`
    A int    `key:"Age" value:"30"`
}

func main() {
    // 定义集合，存储结构体标签
    result := map[string]string{}
    // 实例化结构体
    p := Persons{N: "张三", A: 20}
    // 反射结构体
    vtp := reflect.TypeOf(p)
    // 遍历反射结构体变量的所有成员
    for i := 0; i < vtp.NumField(); i++ {
        // 获取每个成员的结构体成员类型
        vinfo := vtp.Field(i)
        // 输出结构体成员的tag
        tag_key := vinfo.Tag.Get("key")
        tag_value := vinfo.Tag.Get("value")
        result[tag_key] = tag_value
    }
    fmt.Printf("集合的数据：%v\n", result)
}

```

```
集合的数据：map[Age:30 Name:李四]
```

上述代码说明如下：

* 1）定义结构体Person，设置结构体成员N和A，结构体标签设置两个键值对，分别为key和value。
* 2）实例化结构体Person，设置结构体成员N和A的值，使用reflect.TypeOf()对结构体Person创建反射结构体变量。
* 3）由反射结构体变量调用NumField()、Field()和Tag.Get()遍历获取每个结构体成员的标签，将标签数据写入集合变量。


# 反射
## 反射介绍
反射就是在运行期间（不是编译期间）探知对象的类型信息和内存结构、更新变量、调用它们的方法。  
反射的使用场景：  
- 函数的参数类型是interface{}，需要在运行时对原始类型进行判断，针对不同的类型采取不同的处理方式。比如json.Marshal(v interface{})。
- 在运行时根据某些条件动态决定调用哪个函数，比如根据配置文件执行相应的算子函数。  

Go标准库里的json序列化就使用了反射。  
```Go
type User struct {
    Name string
    Age int
    Sex byte `json:"gender"`
}
user := User{
    Name: "钱钟书",
    Age: 57,
    Sex: 1,
}
json.Marshal(user)  //返回 {"Name":"钱钟书","Age":57,"gender":1}
```
反射的弊端：  
- 代码难以阅读，难以维护。
- 编译期间不能发现类型错误，覆盖测试难度很大，有些bug需要到线上运行很长时间才能发现，可能会造成严重用后果。
- 反射性能很差，通常比正常代码慢一到两个数量级。在对性能要求很高，或大量反复调用的代码块里建议不要使用反射。  
## 反射的基础数据类型

<img src=assets/reflect.png width=750 />  

reflect.Type用于获取类型相关的信息。  
```Go
type Type interface {
    Method(int) Method  //第i个方法
    MethodByName(string) (Method, bool) //根据名称获取方法
    NumMethod() int  //方法的个数
    Name() string   //获取结构体名称
    PkgPath() string //包路径
    Size() uintptr  //占用内存的大小
    String() string  //获取字符串表述
    Kind() Kind  //数据类型
    Implements(u Type) bool  //判断是否实现了某接口
    AssignableTo(u Type) bool  //能否赋给另外一种类型
    ConvertibleTo(u Type) bool  //能否转换为另外一种类型
    Elem() Type  //解析指针
    Field(i int) StructField  //第i个成员
    FieldByIndex(index []int) StructField  //根据index路径获取嵌套成员
    FieldByName(name string) (StructField, bool)  //根据名称获取成员
    FieldByNameFunc(match func(string) bool) (StructField, bool)  //
    Len() int  //容器的长度
    NumIn() int  //输出参数的个数
    NumOut() int  //返回参数的个数
}
```
通过reflect.Value获取、修改原始数据类型里的值。  
```Go
type Value struct {
    // 代表的数据类型
    typ *rtype
    // 指向原始数据的指针
    ptr unsafe.Pointer
}
```
## 反射API
### reflect.Type
#### 如何得到Type
通过TypeOf()得到Type类型。
```Go
typeI := reflect.TypeOf(1)       
typeS := reflect.TypeOf("hello") 
fmt.Println(typeI)               //int
fmt.Println(typeS)               //string

typeUser := reflect.TypeOf(&common.User{}) 
fmt.Println(typeUser)                     //*common.User
fmt.Println(typeUser.Kind())                 //ptr
fmt.Println(typeUser.Elem().Kind())    //struct
```
#### 指针Type转为非指针Type
```Go
typeUser := reflect.TypeOf(&common.User{}) 
typeUser2 := reflect.TypeOf(common.User{})
assert.IsEqual(typeUser.Elem(), typeUser2)
```
#### 获取struct成员变量的信息
```Go
typeUser := reflect.TypeOf(common.User{}) //需要用struct的Type，不能用指针的Type
fieldNum := typeUser.NumField()           //成员变量的个数
for i := 0; i < fieldNum; i++ {
    field := typeUser.Field(i)
    fmt.Printf("%d %s offset %d anonymous %t type %s exported %t json tag %s\n", i,
        field.Name,            //变量名称
        field.Offset,          //相对于结构体首地址的内存偏移量，string类型会占据16个字节
        field.Anonymous,       //是否为匿名成员
        field.Type,            //数据类型，reflect.Type类型
        field.IsExported(),    //包外是否可见（即是否以大写字母开头）
        field.Tag.Get("json")) //获取成员变量后面``里面定义的tag
}
fmt.Println()

//可以通过FieldByName获取Field
if nameField, ok := typeUser.FieldByName("Name"); ok {
    fmt.Printf("Name is exported %t\n", nameField.IsExported())
}
//也可以根据FieldByIndex获取Field
thirdField := typeUser.FieldByIndex([]int{2}) //参数是个slice，因为有struct嵌套的情况
fmt.Printf("third field name %s\n", thirdField.Name)
```
#### 获取struct成员方法的信息
```Go
typeUser := reflect.TypeOf(common.User{})
methodNum := typeUser.NumMethod() //成员方法的个数。接收者为指针的方法【不】包含在内
for i := 0; i < methodNum; i++ {
    method := typeUser.Method(i)
    fmt.Printf("method name:%s ,type:%s, exported:%t\n", method.Name, method.Type, method.IsExported())
}
fmt.Println()

typeUser2 := reflect.TypeOf(&common.User{})
methodNum = typeUser2.NumMethod() //成员方法的个数。接收者为指针或值的方法【都】包含在内，也就是说值实现的方法指针也实现了（反之不成立）
for i := 0; i < methodNum; i++ {
    method := typeUser2.Method(i)
    fmt.Printf("method name:%s ,type:%s, exported:%t\n", method.Name, method.Type, method.IsExported())
}
```
#### 获取函数的信息
```Go
func Add(a, b int) int {
    return a + b
}

typeFunc := reflect.TypeOf(Add) //获取函数类型
fmt.Printf("is function type %t\n", typeFunc.Kind() == reflect.Func)
argInNum := typeFunc.NumIn()   //输入参数的个数
argOutNum := typeFunc.NumOut() //输出参数的个数
for i := 0; i < argInNum; i++ {
    argTyp := typeFunc.In(i)
    fmt.Printf("第%d个输入参数的类型%s\n", i, argTyp)
}
for i := 0; i < argOutNum; i++ {
    argTyp := typeFunc.Out(i)
    fmt.Printf("第%d个输出参数的类型%s\n", i, argTyp)
}
```
#### 判断类型是否实现了某接口
```Go
//通过reflect.TypeOf((*<interface>)(nil)).Elem()获得接口类型。因为People是个接口不能创建实例，所以把nil强制转为*common.People类型
typeOfPeople := reflect.TypeOf((*common.People)(nil)).Elem()
fmt.Printf("typeOfPeople kind is interface %t\n", typeOfPeople.Kind() == reflect.Interface)
t1 := reflect.TypeOf(common.User{})
t2 := reflect.TypeOf(&common.User{})
//如果值类型实现了接口，则指针类型也实现了接口；反之不成立
fmt.Printf("t1 implements People interface %t\n", t1.Implements(typeOfPeople))
```
### reflect.Value
#### 如果获得Value
通过ValueOf()得到Value。
```Go
iValue := reflect.ValueOf(1)
sValue := reflect.ValueOf("hello")
userPtrValue := reflect.ValueOf(&common.User{
    Id:     7,
    Name:   "杰克逊",
    Weight: 65,
    Height: 1.68,
})
fmt.Println(iValue)       //1
fmt.Println(sValue)       //hello
fmt.Println(userPtrValue) //&{7 杰克逊  65 1.68}
```
#### Value转为Type
```Go
iType := iValue.Type()
sType := sValue.Type()
userType := userPtrValue.Type()
//在Type和相应Value上调用Kind()结果一样的
fmt.Println(iType.Kind() == reflect.Int, iValue.Kind() == reflect.Int, iType.Kind() == iValue.Kind())  
fmt.Println(sType.Kind() == reflect.String, sValue.Kind() == reflect.String, sType.Kind() == sValue.Kind()) 
fmt.Println(userType.Kind() == reflect.Ptr, userPtrValue.Kind() == reflect.Ptr, userType.Kind() == userPtrValue.Kind())
```
#### 指针Value和非指针Value互相转换
```Go
userValue := userPtrValue.Elem()                    //Elem() 指针Value转为非指针Value
fmt.Println(userValue.Kind(), userPtrValue.Kind())  //struct ptr
userPtrValue3 := userValue.Addr()                   //Addr() 非指针Value转为指针Value
fmt.Println(userValue.Kind(), userPtrValue3.Kind()) //struct ptr
```
#### 得到Value对应的原始数据
通过Interface()函数把Value转为interface{}，再从interface{}强制类型转换，转为原始数据类型。或者在Value上直接调用Int()、String()等一步到位。
```Go
fmt.Printf("origin value iValue is %d %d\n", iValue.Interface().(int), iValue.Int())
fmt.Printf("origin value sValue is %s %s\n", sValue.Interface().(string), sValue.String())
user := userValue.Interface().(common.User)
fmt.Printf("id=%d name=%s weight=%.2f height=%.2f\n", user.Id, user.Name, user.Weight, user.Height)
user2 := userPtrValue.Interface().(*common.User)
fmt.Printf("id=%d name=%s weight=%.2f height=%.2f\n", user2.Id, user2.Name, user2.Weight, user2.Height)
```
#### 空Value的判断
```Go
var i interface{} //接口没有指向具体的值
v := reflect.ValueOf(i)
fmt.Printf("v持有值 %t, type of v is Invalid %t\n", v.IsValid(), v.Kind() == reflect.Invalid)

var user *common.User = nil
v = reflect.ValueOf(user) //Value指向一个nil
if v.IsValid() {
    fmt.Printf("v持有的值是nil %t\n", v.IsNil()) //调用IsNil()前先确保IsValid()，否则会panic
}

var u common.User //只声明，里面的值都是0值
v = reflect.ValueOf(u)
if v.IsValid() {
    fmt.Printf("v持有的值是对应类型的0值 %t\n", v.IsZero()) //调用IsZero()前先确保IsValid()，否则会panic
}
```
#### 通过Value修改原始数据的值
```Go
var i int = 10
var s string = "hello"
user := common.User{
    Id:     7,
    Name:   "杰克逊",
    Weight: 65.5,
    Height: 1.68,
}

valueI := reflect.ValueOf(&i) //由于go语言所有函数传的都是值，所以要想修改原来的值就需要传指针
valueS := reflect.ValueOf(&s)
valueUser := reflect.ValueOf(&user)
valueI.Elem().SetInt(8) //由于valueI对应的原始对象是指针，通过Elem()返回指针指向的对象
valueS.Elem().SetString("golang")
valueUser.Elem().FieldByName("Weight").SetFloat(68.0) //FieldByName()通过Name返回类的成员变量
```
强调一下，要想修改原始数据的值，给ValueOf传的必须是指针，而指针Value不能调用Set和FieldByName方法，所以得先通过Elem()转为非指针Value。  
未导出成员的值不能通过反射进行修改。  
```Go
addrValue := valueUser.Elem().FieldByName("addr")
if addrValue.CanSet() {
    addrValue.SetString("北京")
} else {
    fmt.Println("addr是未导出成员，不可Set") //以小写字母开头的成员相当于是私有成员
}
```
#### 通过Value修改Slice
```Go
users := make([]*common.User, 1, 5) //len=1，cap=5
users[0] = &common.User{
    Id:     7,
    Name:   "杰克逊",
    Weight: 65.5,
    Height: 1.68,
}

sliceValue := reflect.ValueOf(&users) //准备通过Value修改users，所以传users的地址
if sliceValue.Elem().Len() > 0 {      //取得slice的长度
    sliceValue.Elem().Index(0).Elem().FieldByName("Name").SetString("令狐一刀")
    fmt.Printf("1st user name change to %s\n", users[0].Name)
}
```
甚至可以修改slice的cap，新的cap必须位于原始的len到cap之间，即只能把cap改小。
```Go
sliceValue.Elem().SetCap(3)
```
通过把len改大，可以实现向slice中追加元素的功能。
```Go
sliceValue.Elem().SetLen(2)
//调用reflect.Value的Set()函数修改其底层指向的原始数据
sliceValue.Elem().Index(1).Set(reflect.ValueOf(&common.User{
    Id:     8,
    Name:   "李达",
    Weight: 80,
    Height: 180,
}))
fmt.Printf("2nd user name %s\n", users[1].Name)
```
#### 修改map
Value.SetMapIndex()函数：往map里添加一个key-value对。  
Value.MapIndex()函数： 根据Key取出对应的map。  
```Go
u1 := &common.User{
    Id:     7,
    Name:   "杰克逊",
    Weight: 65.5,
    Height: 1.68,
}
u2 := &common.User{
    Id:     8,
    Name:   "杰克逊",
    Weight: 65.5,
    Height: 1.68,
}
userMap := make(map[int]*common.User, 5)
userMap[u1.Id] = u1

mapValue := reflect.ValueOf(&userMap)                                                         //准备通过Value修改userMap，所以传userMap的地址
mapValue.Elem().SetMapIndex(reflect.ValueOf(u2.Id), reflect.ValueOf(u2))                      //SetMapIndex 往map里添加一个key-value对
mapValue.Elem().MapIndex(reflect.ValueOf(u1.Id)).Elem().FieldByName("Name").SetString("令狐一刀") //MapIndex 根据Key取出对应的map
for k, user := range userMap {
    fmt.Printf("key %d name %s\n", k, user.Name)
}
```
#### 调用函数
```Go
valueFunc := reflect.ValueOf(Add) //函数也是一种数据类型
typeFunc := reflect.TypeOf(Add)
argNum := typeFunc.NumIn()            //函数输入参数的个数
args := make([]reflect.Value, argNum) //准备函数的输入参数
for i := 0; i < argNum; i++ {
    if typeFunc.In(i).Kind() == reflect.Int {
        args[i] = reflect.ValueOf(3) //给每一个参数都赋3
    }
}
sumValue := valueFunc.Call(args) //返回[]reflect.Value，因为go语言的函数返回可能是一个列表
if typeFunc.Out(0).Kind() == reflect.Int {
    sum := sumValue[0].Interface().(int) //从Value转为原始数据类型
    fmt.Printf("sum=%d\n", sum)
}
```
#### 调用成员方法
```Go
common.User{
    Id:     7,
    Name:   "杰克逊",
    Weight: 65.5,
    Height: 1.68,
}
valueUser := reflect.ValueOf(&user)              //必须传指针，因为BMI()在定义的时候它是指针的方法
bmiMethod := valueUser.MethodByName("BMI")       //MethodByName()通过Name返回类的成员变量
resultValue := bmiMethod.Call([]reflect.Value{}) //无参数时传一个空的切片
result := resultValue[0].Interface().(float32)
fmt.Printf("bmi=%.2f\n", result)

//Think()在定义的时候用的不是指针，valueUser可以用指针也可以不用指针
thinkMethod := valueUser.MethodByName("Think")
thinkMethod.Call([]reflect.Value{})

valueUser2 := reflect.ValueOf(user)
thinkMethod = valueUser2.MethodByName("Think")
thinkMethod.Call([]reflect.Value{})
```
### 创建对象
#### 创建struct
```Go
user :=t := reflect.TypeOf(common.User{})
value := reflect.New(t) //根据reflect.Type创建一个对象，得到该对象的指针，再根据指针提到reflect.Value
value.Elem().FieldByName("Id").SetInt(10)
user := value.Interface().(*common.User) //把反射类型转成go原始数据类型Call([]reflect.Value{})
```
#### 创建slice
```Go
var slice []common.User
sliceType := reflect.TypeOf(slice)
sliceValue := reflect.MakeSlice(sliceType, 1, 3)
sliceValue.Index(0).Set(reflect.ValueOf(common.User{
    Id:     8,
    Name:   "李达",
    Weight: 80,
    Height: 180,
}))
users := sliceValue.Interface().([]common.User)
fmt.Printf("1st user name %s\n", users[0].Name)
```
#### 创建map
```Go
var userMap map[int]*common.User
mapType := reflect.TypeOf(userMap)
// mapValue:=reflect.MakeMap(mapType)
mapValue := reflect.MakeMapWithSize(mapType, 10)

user := &common.User{
    Id:     7,
    Name:   "杰克逊",
    Weight: 65.5,
    Height: 1.68,
}
key := reflect.ValueOf(user.Id)
mapValue.SetMapIndex(key, reflect.ValueOf(user))                    //SetMapIndex 往map里添加一个key-value对
mapValue.MapIndex(key).Elem().FieldByName("Name").SetString("令狐一刀") //MapIndex 根据Key取出对应的map
userMap = mapValue.Interface().(map[int]*common.User)
fmt.Printf("user name %s %s\n", userMap[7].Name, user.Name)
```
reflect包里除了MakeSlice()和MakeMap()，还有MakeChan()和MakeFunc()。
## 自行实现json序列化
所谓序列化即把struct实例转为string。比如定义了User和Book两个struct。
```Go
type User struct {
    Name string
    Age int
    Sex byte `json:"gender"`
}
type Book struct {
    ISBN string `json:"isbn"`
    Author User `json:"author"`
    Keywords []string `json:"kws"`
}
```
Book的实例序列化后为  
```json
{
    "isbn": "4243547567",
    "author": {
        "Name": "钱钟书",
        "Age": 57,
        "gender": 1
    },
    "kws": ["爱情", "民国", "留学"]
}
```
序列化实现思路：
- 从内向外、从简单到复杂地考虑序列化问题。
    1. 如果要序列化一个int、float、string，很简单。
    2. 如果要序列化一个slice，则在第1步的基础上用[]括起来。
    3. 如果要序列化一个struct，FieldName直接打印出来，FieldValue的序列化可以参考第1、2步。
    4. 如果struct内部还嵌套了struct，则递归调用第3步。
- 通过反射解析struct，得到json key和struct FieldName的对应关系。
- 如果FieldValue是基本的值类型，则通过反射给FieldValue赋值很简单。
- 如果FieldValue是slice类型，则需要通过反射先创建一个slice，再给slice里的每个元素赋值。
- 如果FieldValue是是内嵌struct，则递归调用反序列化函数，给FieldValue赋值。
- 如果FieldValue是是内嵌struct指针，则需要创建内嵌struct对应的实例（申请内存空间），再递归调用反序列化函数，给FieldValue赋值。






```go

```

```

```